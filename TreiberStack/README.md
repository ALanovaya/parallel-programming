# Эксперимент
## Условия

Все эксперименты проводились на машинке с ```ОС Ubuntu 20.04.5 LTS x86_64``` и процессором ```11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz```. 

Рассмотрим [статью](https://www.cs.vu.nl/~wanf/theses/woudenberg-bscthesis.pdf) и полученные в ней результаты, критерием сравнения Elimination-backoff stack и Lock-free stack будет количество мегаопераций в секунду для каждого потока, вычислялось это по формуле:

$$operationNum ∗ 10^9 / ( endTime − startTime )$$


Будем рассматривать 3 сценария на 1 и 6 потоках:
+ Заполняем стек на 100_000 элементов и производим 100_000 операций ``pop()`` (замеряется только производительность операции ``pop()``)
+ Производим 100_000 операцию ``push()``
+ Производим 100 раз операцию ``push()`` и столько же ``pop()``, повторяем данную схему 1000 раз

Производилось 10 запусков для каждого сценария.

## Результаты

Рассмотрим результаты, полученные с использованием 1 потока:

 .| 1| 2| 3|
-------------------|-----------------|-----|---|
Lock-free stack | 24.34| 30.83| 48.47|
Elimination-backoff stack | 20.44| 29.73| 42.12|

По таблице можно сделать вывод о том, что во всех сценариях Lock-free stack отрабатывает лучше в случае 1 потока, чем Elimination-backoff stack, что также подтверждается результатами, отраженными в статье, упомянутой ранее.

Теперь рассмотрим, что поменяется, если использовать 6 потоков:

. | 1| 2| 3|
-------------------|-----------------|-----|---|
Lock-free stack | 0.76| 1.16| 2.32|
Elimination-backoff stack | 0.54| 1.09| 4.83|

Теперь ситуация поменялась, Elimination-backoff stack отробатывает хуже только в первых двух сценариях, причем совсем чуть-чуть отставая от Lock-free stack, этот результат очевиден, так как Elimination-backoff stack тратит лишнее время на проверки и ожидание, в третьем же сценарии он отрабатывает примерно в 2 раза лучше, что согласуется с результатами полученными в статье.
