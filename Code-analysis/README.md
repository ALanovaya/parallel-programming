
# Инструменты анализа кода
[Рассматриваемый проект](https://github.com/shreyas-gopalakrishna/Concurrent-Skip-list) представляет собой реализацию concurrent skip-list, в репозитории помимо исходного кода и тестов также было достаточно подробное описание имплементированной структуры данных, отчет об экспериментах и комментарии по организации кода.
Но в Makefile проекта не был выставлен флаг компиляции `-fsanitize=thread`, из чего можно сделать вывод о том, что скорее всего автор проекта не пользовался какими-либо инструментами для анализа параллельного кода, что привело к многочисленным гонкам данных .

## ThreadSanitizer
Будем запускать тесты, написанные автором:
+ Unit Test 1 -- в данном тесте используется 4 потока, сначала числа от 1 до 30 добавляются в список, после выполняется удаление нескольких элементов, поиск и ранжирование.
```ThreadSanitizer: reported 9 warnings```.
+ Unit Test 2 -- в данном тесте используется 8 потоков, в список добавляются числа от 1 до 2000 и повторяются те же операции, что и в первом тесте.
```ThreadSanitizer: reported 15 warnings```.
+ Unit Test 3 -- в данном тесте используется 8 потоков. Все потоки вызывают функцию, которая выполняет вставку, удаление, поиск и ранжирование со случайными числами от 1 до 5000.
```ThreadSanitizer: reported 55 warnings```.

Все предупреждения были только о гонках данных, возникающих в различных местах программы ```WARNING: ThreadSanitizer: data race```.

## Helgrind
Обнаружил больше ошибок, так как детектил гонку данных при каждой операции над списком 
+ Unit Test 1: ```ERROR SUMMARY: 353 errors from 21 contexts (suppressed: 419 from 64)```
+ Unit Test 2: ```ERROR SUMMARY: 816 errors from 12 contexts (suppressed: 2700 from 17)```
+ Unit Test 3: ```ERROR SUMMARY: 29774 errors from 44 contexts (suppressed: 79793 from 51)```
## Причины 
1.  **Доступ к общим переменным без блокировки**: В функциях  `add`,  `remove`  и  `search`  использование общих переменных, таких как  `head`,  `tail`  и  `max_level`, может привести к гонке данных, если эти переменные изменяются одновременно из разных потоков.
    
2.  **Изменение указателей  `next`  без блокировки**: В функциях  `add`  и  `remove`, указатели  `next`  перестраиваются для вставки или удаления узлов. Если один поток изменяет указатель, в то время как другой поток пытается пройти по этим указателям, это может привести к гонке данных.
    
3.  **Проверка и изменение  `marked`  и  `fully_linked`**: В функции  `remove`  узел помечается как  `marked`  и проверяется на  `fully_linked`, что может привести к гонке, если другие потоки одновременно читают или пишут в эти поля без блокировки.
    
4.  **Неправильное использование блокировок**: Несмотря на то, что в коде присутствует механизм блокировки узлов, ошибки в логике захвата и освобождения блокировок могут привести к тому, что не все критические секции будут корректно защищены. В частности, в  `add`  и  `remove`  есть попытки захватить блокировку для предшественников (`preds`) на разных уровнях. Если это сделано некорректно или если блокировки не освобождаются в случае исключения, это может привести к гонке данных.
    
5.  **Неатомарные операции с проверками**: В  `add`  и  `remove`  есть проверки типа  `pred->marked.load(std::memory_order_seq_cst)`  и  `pred->next[level]==succ`  без захвата блокировки, что может привести к гонке, так как другой поток может изменить эти значения между проверками и операциями над данными.

## Ссылки
+ [Перевод оригинальной статьи 1990г. W.Pugh о списке с пропусками](https://habr.com/ru/articles/230413/)
+ [Статья о lock-free skip-list](https://habr.com/ru/articles/250815/)

